/*
 * Copyright 2020 LinkedIn Corp.
 * Licensed under the BSD 2-Clause License (the "License").â€¨
 * See License in the project root for license information.
 */

plugins {
  id "java-library"
}

configurations {
  avro14
  avro17
  avro18
}

test {
  //we run test multiple times with different avro
  //versions, so don't use the default test task
  enabled = false
}

def AVRO_14 = "org.apache.avro:avro:1.4.1"
def AVRO_17 = "org.apache.avro:avro:1.7.7"
def AVRO_18 = "org.apache.avro:avro:1.8.2"
def USE_AVRO_14 = project.hasProperty("USE_AVRO_14") ? true : false
def USE_AVRO_17 = project.hasProperty("USE_AVRO_17") ? true : false
// default to use Avro-1.8 lib
def AVRO_LIB = AVRO_18
def USE_AVRO_18 = true
if (USE_AVRO_14) {
  AVRO_LIB = AVRO_14
  USE_AVRO_18 = false
} else if (USE_AVRO_17) {
  AVRO_LIB = AVRO_17
  USE_AVRO_18 = false
}

dependencies {
  compile project(":helper:helper")

  compile "org.slf4j:slf4j-log4j12:1.7.14"
  compile "org.apache.commons:commons-lang3:3.4"
  compile "com.sun.codemodel:codemodel:2.6"
  compile "com.google.guava:guava:19.0"

  // By default, the compile and testCompile configuration is using avro-1.8, and
  // if you need to switch to an old version of Avro, we need to make
  // sure the test classes is generated by the old version of Avro by
  // executing the following gradle task: 'generateAvroClasses14' or
  // 'generateAvroClasses17' based on which Avro version you choose.
  compileOnly AVRO_LIB

  testCompileOnly AVRO_LIB

  testCompile 'org.testng:testng:6.14.3'
  testCompile "org.openjdk.jmh:jmh-core:1.19"
  testCompile "org.openjdk.jmh:jmh-generator-annprocess:1.19"

  avro14 ("org.apache.avro:avro:1.4.1") {
    exclude group: "org.mortbay.jetty"
    exclude group: "org.apache.velocity"
    exclude group: "commons-lang"
    exclude group: "org.jboss.netty"
    exclude group: "com.thoughtworks.paranamer", module: "paranamer-ant"
    exclude group: "org.slf4j"
  }
  avro17 ("org.apache.avro:avro:1.7.7") {
    exclude group: "org.slf4j"
  }
  avro18 ("org.apache.avro:avro-compiler:1.8.2") {
    exclude group: "org.slf4j"
  }
}

def avroVersions = ["14", "17", "18"]

for (String avroVersion : avroVersions) {

  task "testAvro${avroVersion}" (type: Test, group: "Verification", description: "runs unit tests with avro ${avroVersion}") {

    useTestNG() {
      excludeGroups "perfTest"
    }

    testLogging {
      events "passed", "skipped", "failed"
    }

    classpath = project.sourceSets.test.runtimeClasspath.filter {
      File file -> !(file.name.contains("avro") && !file.name.contains("helper"))
    }.plus (configurations."avro${avroVersion}")

    def gradleIsFun = avroVersion

    doFirst {
      System.out.println("classpath for avro " + gradleIsFun + " is:")
      classpath.each { System.out.println(it) }
    }
  }
}

test {
  testLogging.showStandardStreams = true
}

build.dependsOn testAvro14, testAvro17, testAvro18

task generateAvroClasses14(type:Exec) {
  commandLine "./regenerate_avro.sh"
  args "default_avro_140"
}

task generateAvroClasses17(type:Exec) {
  commandLine "./regenerate_avro.sh"
  args "default_avro_177"
}

task generateAvroClasses18(type:Exec) {
  commandLine "./regenerate_avro.sh"
  args "default_avro_182"
}

task whetherToCompileAvroClasses18() {
  if (USE_AVRO_18) {
    dependsOn generateAvroClasses18
  }
}
// Only pre-compile for Avro-1.8 since the default Avro version is 1.8
compileTestJava.dependsOn whetherToCompileAvroClasses18

// Need to create several similar tasks since gradle will only run the same task at most once,
// but we need to clean up and re-compile for each Avro version since the avro classes will be
// generated with every Avro version.
task cleanupAndRebuildTestsForAvro14(type:Exec) {
  workingDir '../'
  commandLine './gradlew', 'avro-fastserde:clean', 'avro-fastserde:testClasses', '-PUSE_AVRO_14'
}
task cleanupAndRebuildTestsForAvro17(type:Exec) {
  workingDir '../'
  commandLine './gradlew', 'avro-fastserde:clean', 'avro-fastserde:testClasses', '-PUSE_AVRO_17'
}
task cleanupAndRebuildTestsForAvro18(type:Exec) {
  workingDir '../'
  commandLine './gradlew', 'avro-fastserde:clean', 'avro-fastserde:testClasses'
}
cleanupAndRebuildTestsForAvro14.dependsOn generateAvroClasses14
cleanupAndRebuildTestsForAvro17.dependsOn generateAvroClasses17
cleanupAndRebuildTestsForAvro18.dependsOn generateAvroClasses18

testAvro14.dependsOn cleanupAndRebuildTestsForAvro14
testAvro17.dependsOn cleanupAndRebuildTestsForAvro17
testAvro18.dependsOn cleanupAndRebuildTestsForAvro18

//custom publishing code to export a depndency on "helper-all":

task sourceJar(type: Jar) {
  from sourceSets.main.allJava
  classifier "sources"
}

task javadocJar(type: Jar) {
  from javadoc
  classifier = 'javadoc'
}

task testJar(type: Jar) {
  from sourceSets.test.allJava
  classifier = 'tests'
}

publishing {
  publications {
    "$project.name"(MavenPublication) {
      groupId project.group
      artifactId project.name
      version project.version

      from components.java
      artifact sourceJar
      artifact javadocJar
      artifact testJar

      //we strive to meet https://central.sonatype.org/pages/requirements.html
      pom {
        name = 'Avro Util'
        description = 'utilities for writing code that works across major avro versions'
        url = 'https://github.com/linkedin/avro-util'

        licenses {
          license {
            name = 'BSD 2-Clause'
            url = 'https://raw.githubusercontent.com/linkedin/avro-util/master/LICENSE'
          }
        }
        developers {
          developer {
            id = 'radai-rosenblatt'
            name = 'Radai Rosenblatt'
            email = 'radai.rosenblatt@gmail.com'
            organization = 'LinkedIn'
            organizationUrl = 'linkedin.com'
          }
          developer {
            id = 'abhishekmendhekar'
            name = 'Abhishek Mendhekar'
            organization = 'LinkedIn'
            organizationUrl = 'linkedin.com'
          }
          developer {
            id = 'jimhe'
            name = 'Jim He'
            email = 'jimjhe@gmail.com'
            organization = 'LinkedIn'
            organizationUrl = 'linkedin.com'
          }
          developer {
            id = 'ghosthack'
            name = 'Adrian Fernandez'
            email = 'adrian@ghosthack.com'
            organization = 'LinkedIn'
            organizationUrl = 'linkedin.com'
          }
        }
        scm {
          connection = 'scm:git:git://github.com:linkedin/avro-util.git'
          developerConnection = 'scm:git:ssh://github.com:linkedin/avro-util.git'
          url = 'https://github.com/linkedin/avro-util'
        }
      }

      //remove the dependency on helper, and replace with one on helper-all
      pom.withXml {
        Node dependenciesNode = (Node) (asNode().dependencies[0])
        Collection<Node> dependencyNodes = dependenciesNode.children()
        List<Node> toRemove = new ArrayList<>()

        for (Node o : dependencyNodes) {
          if ("$project.group" == o.groupId[0].text() && "helper" == o.artifactId[0].text()) {
            toRemove.add(o)
          }
        }

        for (Node o : toRemove) {
          dependencyNodes.remove(o)
        }

        def dependencyNode = dependenciesNode.appendNode('dependency')
        dependencyNode.appendNode('groupId', "$project.group")
        dependencyNode.appendNode('artifactId', "helper-all")
        dependencyNode.appendNode('version', "$project.version")
        dependencyNode.appendNode('scope', "compile")
      }
    }

    //record all of this module's publications in the bintray publications list
    //for the root project
    List<String> allPublicationNames = new ArrayList<>(Arrays.asList(rootProject.bintray.publications))
    List<String> projectAndDepPublicationNames = new ArrayList<>(project.publishing.publications.names)
    for (String projectPubName : projectAndDepPublicationNames) {
      if (!allPublicationNames.contains(projectPubName)) {
        allPublicationNames.add(projectPubName)
      }
    }
    rootProject.bintray.publications = allPublicationNames.toArray()
  }
}
