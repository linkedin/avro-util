/*
 * Copyright 2020 LinkedIn Corp.
 * Licensed under the BSD 2-Clause License (the "License").
 * See License in the project root for license information.
 */

package com.linkedin.avro.codegen;

import com.beust.jcommander.Parameter;
import com.linkedin.avro.compatibility.AvroVersion;
import java.io.File;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;


public class ToolArgs {
  @Parameter(names = "-src", required = true, description = "files or folders to generate code for", converter = StringToFileConverter.class)
  private Set<File> src;
  @Parameter(names = "-include", description = "include patterns. default is \"**/*.avsc\"")
  private Set<String> includes = new HashSet<>(Collections.singletonList("**/*.avsc"));
  @Parameter(names = "-importable", description = "patterns for importable schema files. default is \"**/*.*\"")
  private Set<String> importablePatterns = new HashSet<>(Collections.singletonList("**/*.*"));
  //if true will go fishing on the classpath for generated specific record classes of missing schemas
  @Parameter(names = "-allow-cp", description = "allow looking up undefined schemas on the classpath")
  private boolean allowClasspathLookup = true;
  //if true, and we find a SpecificFixed or Enum class on the classpath (see allowClasspathLookup above)
  //and this class we find was generated by horrible ancient avro and not made compatible (so we cant get
  //its actual schema from it) we can try and "guess" the schema by the class' contents.
  //this has an interesting side effect of allowing avro schemas to use just any java enum ...
  @Parameter(names = "-allow-guessing", description = "allow generating schemas for classpath classes that dont have them")
  private boolean allowReverseEngineeringClasspathSchemas = false;
  //top-level schema a.b.c.X must be in a file who's path from root is a/b/c/*.avsc
  @Parameter(names = "-validate-path")
  private boolean validateSchemaNamespaceVsFilePath = true;
  //top-level schema called a.b.c.X must be in a file called X.avsc
  @Parameter(names = "-validate-name")
  private boolean validateSchemaNameVsFileName = true;
  //if != null, would post-process the code to make it runtime-compatible with the designated version and onwards
  private AvroVersion minTargetAvroVersion = AvroVersion.AVRO_1_4;
  //output root for java files (or null, in which case no results will be written to disk)
  @Parameter(names = "-dest", required = true, description = "destination root folder", converter = StringToFileConverter.class)
  private File outputFolder;

  public Set<File> getSrc() {
    return src;
  }

  public Set<String> getIncludes() {
    return includes;
  }

  public Set<String> getImportablePatterns() {
    return importablePatterns;
  }

  public boolean isAllowClasspathLookup() {
    return allowClasspathLookup;
  }

  public boolean isAllowReverseEngineeringClasspathSchemas() {
    return allowReverseEngineeringClasspathSchemas;
  }

  public boolean isValidateSchemaNamespaceVsFilePath() {
    return validateSchemaNamespaceVsFilePath;
  }

  public boolean isValidateSchemaNameVsFileName() {
    return validateSchemaNameVsFileName;
  }

  public AvroVersion getMinTargetAvroVersion() {
    return minTargetAvroVersion;
  }

  public File getOutputFolder() {
    return outputFolder;
  }
}
